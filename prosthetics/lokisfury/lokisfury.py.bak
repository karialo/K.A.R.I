# prosthetics/lokisfury/lokisfury.py
# Updated: flexible action signatures, kwargs/raw parsing, aliases, default-run for no-args.
# - Standalone-friendly fallbacks for core.logger, core.personality, MemoryCortex, and requests.
# - __main__ REPL runner for quick testing without the whole K.A.R.I. service.
# - Rich `meta_data["help"]` entries so DEVILCore's help system can surface readable docs.

import os
import shlex
import socket
import platform
import getpass
import hashlib
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any

# Try requests, fall back to urllib if not present (graceful)
try:
    import requests  # type: ignore
except Exception:
    requests = None

# ---- guarded imports for K.A.R.I. core shims ----
# Provide lightweight fallbacks so the module can be imported and run standalone.

# core.logger
try:
    from core.logger import log_system, log_kari  # type: ignore
except Exception:
    def log_system(msg: str, source: str | None = None, level: str = "INFO") -> None:
        src = source or "Lokisfury"
        print(f"[{level}] {src} | {msg}", flush=True)

    def log_kari(msg: str, module_name: str = "K.A.R.I") -> None:
        print(f"[KARI] {module_name}: {msg}", flush=True)

# core.personality
try:
    from core.personality import get_phrase  # type: ignore
except Exception:
    def get_phrase(module_key: str, tag: str, mood: str) -> str:
        return f"[{module_key}] ({mood}) {tag}"

# MemoryCortex (class may be present in internal.*), keep as class or None
try:
    from internal.memory_cortex.memory_cortex import MemoryCortex  # type: ignore
except Exception:
    MemoryCortex = None  # type: ignore

# Try to reuse your LokisFury package internals if present (optional)
try:
    from LokisFury import network as lf_net  # type: ignore
    from LokisFury import hashes as lf_hashes  # type: ignore
except Exception:
    lf_net = None
    lf_hashes = None

# Debug flag: environment override or core settings
try:
    from core import settings as _kari_settings  # type: ignore
    DEBUG = bool(int(os.environ.get("KARI_DEBUG", "0"))) or bool(getattr(_kari_settings, "DEBUG", False))
except Exception:
    DEBUG = bool(int(os.environ.get("KARI_DEBUG", "0")))

meta_data = {
    "name": "Lokisfury",
    "version": "1.0",
    "author": "Change me",
    "description": "Network and hash utilities (portscan, public_ip, hasher, hashcrack, localinfo)",
    "category": "prosthetic",
    # include both styles in actions to help discovery UIs
    "actions": ['portscan', 'public_ip', 'public-ip', 'hasher', 'hashcrack', 'localinfo'],
    "manual_actions": [
        {"name": "Report Module Alive", "function": "report_alive"},
        {"name": "Display Module Info", "function": "display_info"}
    ],
    "pulse": ["pulse"],
    "capabilities": ["neural_sync"],
    "resources": ["cpu_usage", "mem_usage"],
    # helpful alias map: external names -> real method names (pythonic)
    "aliases": {
        "public-ip": "public_ip",
        "public_ip": "public_ip",
        "scanPorts": "portscan",
        "port-scan": "portscan"
    },
    # Rich help content surfaced by DEVILCore help system
    "help": {
        "_module": (
            "Lokisfury – small utilities for network pokes and hash operations.\n\n"
            "Design notes:\n"
            " - Actions accept either JSON kwargs (recommended when calling via `kari call`)\n"
            "   or a raw argument string which the module will parse (handy for CLI usage).\n"
            " - This module is friendly to being imported standalone (provides fallbacks)\n"
            "   so you can run `python prosthetics/lokisfury/lokisfury.py` for a quick REPL.\n"
            " - When calling through the socket client, the third argument can be a JSON\n"
            "   object (e.g. `'{\"target\":\"127.0.0.1\",\"max_port\":200}'`) or a raw\n"
            "   string (`'127.0.0.1 --max-port 200'`)."
        ),
        "public_ip": (
            "Usage:\n"
            "  public_ip\n\n"
            "Returns the public IP address as a short string. When requests is available\n"
            "it will call https://api.ipify.org; otherwise it falls back to urllib."
        ),
        "localinfo": (
            "Usage:\n"
            "  localinfo\n\n"
            "Returns basic local information (hostname, username, OS, platform). Useful\n"
            "for quick diagnostics from within K.A.R.I."
        ),
        "portscan": (
            "Usage:\n"
            "  portscan <host> [--max-port N] [--concurrency N] [--timeout S]\n\n"
            "Or call with JSON kwargs:\n"
            "  {\"target\":\"192.168.0.1\", \"max_port\":200, \"concurrency\":100, \"timeout\":0.2}\n\n"
            "Notes:\n"
            " - Default max_port: 1024\n"
            " - Default concurrency: 100 (kept between 10 and 1000)\n"
            " - Default timeout: 0.3s\n\n"
            "Examples:\n"
            "  kari call Lokisfury portscan '192.168.0.1 --max-port 200'\n"
            "  kari call Lokisfury portscan '{\"target\":\"192.168.0.1\",\"max_port\":200}'"
        ),
        "hasher": (
            "Usage:\n"
            "  hasher <text> [--algo md5|sha1|sha256|sha512|all]\n\n"
            "Or call with JSON kwargs:\n"
            "  {\"text\":\"hello world\", \"algo\":\"sha256\"}\n\n"
            "Notes:\n"
            " - Default algorithm: all (md5, sha1, sha256, sha512)\n"
            "Examples:\n"
            "  kari call Lokisfury hasher '{\"text\":\"hello world\"}'\n"
            "  kari call Lokisfury hasher 'hello --algo sha256'"
        ),
        "hashcrack": (
            "Usage:\n"
            "  hashcrack <algo|auto> <hash> [--wordlist FILE]\n\n"
            "Or call with JSON kwargs:\n"
            "  {\"algo\":\"auto\",\"hash\":\"<value>\",\"wordlist\":\"/path/to/file\"}\n\n"
            "Notes:\n"
            " - If algo is 'auto' the module will attempt to guess md5/sha1/sha256/sha512\n"
            "   based on hash length.\n"
            " - Default wordlist: $DEFAULT_WORDLIST or ~/.wordlists/rockyou.txt\n\n"
            "Examples:\n"
            "  kari call Lokisfury hashcrack 'auto 3e2573...' --wordlist passwords.txt\n"
            "  kari call Lokisfury hashcrack '{\"algo\":\"sha256\",\"hash\":\"...\",\"wordlist\":\"./pw.txt\"}'"
        )
    }
}


class Lokisfury:
    def __init__(self):
        self.meta_data = meta_data
        self.name = self.meta_data["name"]
        self.shared_data: dict[str, Any] = {}
        self.core = None  # assigned by DEVILCore at runtime
        self.ready = False
        self.available_phrases: list[str] = []

    # -------------------------- lifecycle --------------------------------
    def init(self):
        """Called by the core when loading the module."""
        self.ready = False
        self.available_phrases = self._load_available_phrases()
        if self.available_phrases:
            log_system("Available phrase triggers loaded:", source=self.name)
            for phrase in sorted(self.available_phrases):
                log_system(f" • {phrase}", source=self.name)
        else:
            log_system("No phrase files detected. K.A.R.I. may be speechless.", source=self.name)
        if DEBUG:
            log_system("DEBUG enabled for module.", source=self.name)
        self.ready = True

    # --------------------------- utils -----------------------------------
    def log(self, message: str):
        """Convenience wrapper to the core logger(s)."""
        try:
            log_system(message, source=self.name)
        except Exception:
            try:
                log_kari(message)
            except Exception:
                print(f"[{self.name}] {message}", flush=True)

    def _current_mood(self) -> str:
        # Lazy MemoryCortex instantiation to avoid import-time side-effects
        if MemoryCortex:
            try:
                inst = MemoryCortex()
                return inst.get_current_mood() or "neutral"
            except Exception:
                return "neutral"
        return "neutral"

    def _safe_phrase(self, module_key: str, tag: str, mood: str):
        try:
            return get_phrase(module_key, tag, mood)
        except Exception as e:
            if DEBUG:
                self.log(f"get_phrase() failed for tag '{tag}' mood '{mood}': {e}")
            return f"[{self.name}] ({mood}) {tag}"

    def react(self, phrase_file: str, override_mood: str | None = None) -> str:
        mood = override_mood or self._current_mood()
        return self._safe_phrase("lokisfury", phrase_file, mood)

    def _load_available_phrases(self):
        phrases_path = os.path.join(os.path.dirname(__file__), "phrases")
        if not os.path.exists(phrases_path):
            return []
        subdirs = [f for f in os.listdir(phrases_path) if os.path.isdir(os.path.join(phrases_path, f))]
        return subdirs

    # -------------------------- diagnostics -------------------------------
    def report_alive(self):
        self.log("Status: Online and operational.")
        return "OK"

    def display_info(self):
        for key, value in self.meta_data.items():
            self.log(f"{key}: {value}")
        return self.collect_info()

    def healthcheck(self):
        return {
            "name": self.name,
            "ready": self.ready,
            "has_core": self.core is not None
        }

    # ----------------------- DEVILCore data sync --------------------------
    def pulse(self):
        """Called periodically by core to sync shared data into module."""
        if hasattr(self, "core") and hasattr(self.core, "data_store") and self.core.data_store is not None:
            try:
                self.shared_data.update(self.core.data_store)  # shallow sync
                if DEBUG:
                    cpu = self.shared_data.get("cpu_usage")
                    mem = self.shared_data.get("mem_usage")
                    if cpu is not None or mem is not None:
                        self.log(f"Synced shared data (cpu={cpu}, mem={mem})")
                    else:
                        self.log("Synced shared data.")
            except Exception as e:
                self.log(f"Pulse sync failed: {e}")
        else:
            if DEBUG:
                self.log("No DEVILCore data_store to sync.")

    def push_shared_data(self):
        """Optional; publish data back into core.data_store if needed."""
        if hasattr(self, "core") and hasattr(self.core, "data_store") and self.core.data_store is not None:
            pass

    def show_shared_data(self):
        if not self.shared_data:
            self.log("No shared data found.")
        else:
            self.log("Shared data:")
            for k, v in self.shared_data.items():
                self.log(f"  {k}: {v}")

    def collect_info(self):
        return {
            "Module Info": {
                "name": self.meta_data["name"],
                "version": self.meta_data["version"],
                "author": self.meta_data["author"],
                "description": self.meta_data["description"]
            },
            "State": {
                "ready": self.ready
            },
            "Actions": self.meta_data.get("actions", [])
        }

    # -------------------------- helpers ----------------------------------
    @staticmethod
    def _auto_algo_from_hash(h: str) -> str | None:
        s = h.strip().lower()
        if all(c in "0123456789abcdef" for c in s):
            L = len(s)
            if L == 32:
                return "md5"
            if L == 40:
                return "sha1"
            if L == 64:
                return "sha256"
            if L == 128:
                return "sha512"
        return None

    @staticmethod
    def _hash_of(text: str, algo: str) -> str:
        fmap = {
            "md5": hashlib.md5,
            "sha1": hashlib.sha1,
            "sha256": hashlib.sha256,
            "sha512": hashlib.sha512,
        }
        if algo not in fmap:
            raise ValueError(f"Unsupported algo: {algo}")
        h = fmap[algo]()
        h.update(text.encode("utf-8", errors="ignore"))
        return h.hexdigest()

    # tolerant numeric parsers to handle stray JSON/shell junk like "10000}" or "'1000'"
    @staticmethod
    def _clean_num_token(x: object) -> str:
        """Strip quotes/braces/commas that sometimes sneak in via shell/JSON."""
        if x is None:
            return ""
        s = str(x)
        # strip surrounding whitespace
        s = s.strip()
        # remove surrounding quotes
        if (s.startswith("'") and s.endswith("'")) or (s.startswith('"') and s.endswith('"')):
            s = s[1:-1]
        # strip common trailing/leading braces/commas
        s = s.strip().lstrip("{").rstrip("},").rstrip("}").rstrip(",")
        return s

    @classmethod
    def _as_int(cls, x: object, default: int | None = None) -> int:
        try:
            return int(cls._clean_num_token(x))
        except Exception:
            if default is None:
                raise
            return default

    @classmethod
    def _as_float(cls, x: object, default: float | None = None) -> float:
        try:
            return float(cls._clean_num_token(x))
        except Exception:
            if default is None:
                raise
            return default

    # -------------------------- param helpers -----------------------------
    def _extract_str_arg(self, args, kwargs) -> str:
        """
        Normalize input into a single command string.
        - If positional args present and first is a string, use that.
        - If kwargs contains 'raw', 'raw_args', 'args', 'target', build sensible string.
        - Otherwise return empty string.
        """
        if args:
            # prefer the first positional arg as raw string (or list -> join)
            first = args[0]
            if isinstance(first, str):
                return first
            if isinstance(first, (list, tuple)):
                return " ".join(map(str, first))
            if isinstance(first, dict):
                # convert dict -> flag string where sensible
                return " ".join(f"--{k} {v}" for k, v in first.items())
        # look for common kwargs
        for k in ("raw", "raw_args", "args", "target", "host"):
            if k in kwargs and kwargs[k] is not None:
                v = kwargs[k]
                if isinstance(v, str):
                    return v
                if isinstance(v, (list, tuple)):
                    return " ".join(map(str, v))
                if isinstance(v, dict):
                    return " ".join(f"--{kk} {vv}" for kk, vv in v.items())
        # if kwargs is a single-key dict with keys matching named params (e.g., {'target': '1.2.3.4'})
        if kwargs:
            # crude join to allow {"target":"1.2.3.4","ports":"1-100"} -> "--target 1.2.3.4 --ports 1-100"
            return " ".join(f"--{k} {v}" for k, v in kwargs.items())
        return ""

    # -------------------------- actions ---------------------------------
    def public_ip(self, *args, **kwargs) -> str | None:
        """
        Returns the public IP. Works when called:
         - no args: return ip (CLI friendly)
         - raw string in args/kwargs ignored for this action
        """
        try:
            if requests:
                ip = requests.get("https://api.ipify.org", timeout=6).text.strip()
            else:
                # fallback to urllib
                from urllib.request import urlopen  # type: ignore
                with urlopen("https://api.ipify.org", timeout=6) as fh:
                    ip = fh.read().decode("utf-8").strip()
            return f"Public IP: {ip}"
        except Exception as e:
            return f"Public IP: Error: {e}"

    def localinfo(self, *args, **kwargs) -> str | None:
        """Return local host info. Works with or without args."""
        data = {
            "hostname": socket.gethostname(),
            "username": getpass.getuser(),
            "os": platform.system(),
            "platform": platform.platform()
        }
        longest = max(len(k) for k in data)
        lines = [f"{k.ljust(longest)} : {v}" for k, v in data.items()]
        return "\n".join(lines)

    def portscan(self, *args, **kwargs) -> str | None:
        """
        portscan usage:
          - portscan <host> [--max-port N] [--concurrency N] [--timeout S]
          - or as kwargs: {"target":"host", "max_port":1024, "concurrency":100}
        """
        raw = self._extract_str_arg(args, kwargs)
        args_list = shlex.split(raw) if raw else []

        # defaults
        host = None
        max_port = 1024
        concurrency = 100
        timeout = 0.3

        i = 0
        while i < len(args_list):
            a = args_list[i]
            if a in ("--max-port", "-m") and i + 1 < len(args_list):
                i += 1
                max_port = self._as_int(args_list[i], default=max_port)
            elif a.startswith("--max-port="):
                max_port = self._as_int(a.split("=", 1)[1], default=max_port)
            elif a in ("--concurrency", "-c") and i + 1 < len(args_list):
                i += 1
                concurrency = self._as_int(args_list[i], default=concurrency)
            elif a.startswith("--concurrency="):
                concurrency = self._as_int(a.split("=", 1)[1], default=concurrency)
            elif a == "--timeout" and i + 1 < len(args_list):
                i += 1
                timeout = self._as_float(args_list[i], default=timeout)
            elif a.startswith("--timeout="):
                timeout = self._as_float(a.split("=", 1)[1], default=timeout)
            elif a.startswith("-"):
                return f"Unknown option: {a}"
            else:
                host = a
            i += 1

        # also accept kwargs directly (more structured)
        if not host and "target" in kwargs:
            host = kwargs.get("target")
        if not host and "host" in kwargs:
            host = kwargs.get("host")
        if "max_port" in kwargs:
            try:
                max_port = self._as_int(kwargs.get("max_port"), default=max_port)
            except Exception:
                pass
        if "concurrency" in kwargs:
            try:
                concurrency = self._as_int(kwargs.get("concurrency"), default=concurrency)
            except Exception:
                pass
        if "timeout" in kwargs:
            try:
                timeout = self._as_float(kwargs.get("timeout"), default=timeout)
            except Exception:
                pass

        if not host:
            return "Error: host required.\nUsage:\n  portscan <host> [--max-port N] [--concurrency N] [--timeout S]"

        def scan_port(p: int) -> bool:
            if lf_net and hasattr(lf_net, "_scan_port"):
                try:
                    return lf_net._scan_port(host, p, timeout=timeout)
                except Exception:
                    pass
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(timeout)
                    return s.connect_ex((host, p)) == 0
            except Exception:
                return False

        open_ports: list[int] = []
        # keep concurrency sane
        concurrency = max(10, min(concurrency, 1000))
        with ThreadPoolExecutor(max_workers=concurrency) as ex:
            futures = {ex.submit(scan_port, p): p for p in range(1, max_port + 1)}
            for fut in as_completed(futures):
                p = futures[fut]
                try:
                    if fut.result():
                        open_ports.append(p)
                except Exception:
                    pass

        open_ports.sort()
        if open_ports:
            return f"Open ports: {', '.join(map(str, open_ports))}"
        return "No open ports found."

    def hasher(self, *args, **kwargs) -> str | None:
        """
        hasher <text> [--algo md5|sha1|sha256|sha512|all]
        Accepts positional or kwargs: {"text":"hello","algo":"md5"}
        """
        raw = self._extract_str_arg(args, kwargs)
        parts = shlex.split(raw) if raw else []

        text = None
        algo = "all"
        i = 0
        while i < len(parts):
            a = parts[i]
            if a == "--algo" and i + 1 < len(parts):
                i += 1
                algo = parts[i].lower()
            elif a.startswith("--algo="):
                algo = a.split("=", 1)[1].lower()
            elif a.startswith("-"):
                return f"Unknown option: {a}"
            else:
                text = a if text is None else f"{text} {a}"
            i += 1

        # kwargs support
        if not text and "text" in kwargs:
            text = kwargs.get("text")
        if "algo" in kwargs and kwargs.get("algo") is not None:
            algo = str(kwargs.get("algo")).lower()

        if not text:
            return "Error: text required.\nUsage:\n  hasher <text> [--algo md5|sha1|sha256|sha512|all]"

        algos = ["md5", "sha1", "sha256", "sha512"] if algo == "all" else [algo]
        lines: list[str] = []
        for a in algos:
            try:
                digest = self._hash_of(text, a)
                lines.append(f"{a}: {digest}")
            except Exception as e:
                lines.append(f"{a}: Error: {e}")
        return "\n".join(lines)

    def hashcrack(self, *args, **kwargs) -> str | None:
        """
        hashcrack <algo|auto> <hash> [--wordlist FILE]
        Accepts kwargs: {"algo":"auto","hash":"...","wordlist":"/path"}
        """
        raw = self._extract_str_arg(args, kwargs)
        parts = shlex.split(raw) if raw else []

        if len(parts) < 2:
            # fallback to kwargs
            algo = kwargs.get("algo")
            target = kwargs.get("hash") or kwargs.get("target")
            wordlist = kwargs.get("wordlist")
            if not algo or not target:
                return "Usage:\n  hashcrack <algo|auto> <hash> [--wordlist FILE]"
        else:
            algo = parts[0].lower()
            target = parts[1]
            wordlist = None
            for i, a in enumerate(parts[2:], start=2):
                if a in ("-w", "--wordlist") and i + 1 < len(parts):
                    wordlist = parts[i + 1]
                elif a.startswith("--wordlist="):
                    wordlist = a.split("=", 1)[1]

        if algo == "auto":
            det = self._auto_algo_from_hash(target)
            if not det:
                return "Could not auto-detect algorithm from hash."
            algo = det

        if not wordlist:
            wordlist = os.environ.get("DEFAULT_WORDLIST") or os.path.expanduser("~/.wordlists/rockyou.txt")

        try:
            with open(os.path.expanduser(wordlist), "r", errors="ignore") as fh:
                for line in fh:
                    word = line.strip()
                    if not word:
                        continue
                    if lf_hashes and hasattr(lf_hashes, "_hash_of"):
                        ok = lf_hashes._hash_of(word, algo) == target
                    else:
                        ok = self._hash_of(word, algo) == target
                    if ok:
                        return f"[+] Found: {word}"
            return "[-] Not found in provided wordlist."
        except FileNotFoundError:
            return f"Wordlist not found: {wordlist}"


# ------------------ handy cli/test runner when module executed directly ------------------
def _interactive_runner():
    """
    Quick interactive runner for developers:
      python prosthetics/lokisfury/lokisfury.py
    Provides `inst` object in local REPL.
    """
    inst = Lokisfury()
    inst.core = type("FakeCore", (), {"data_store": {}, "name": "FAKECORE"})
    try:
        inst.init()
    except Exception as e:
        print("init() raised:", e)
    print("Lokisfury instance ready as 'inst'. Examples:")
    print("  inst.public_ip()")
    print("  inst.localinfo()")
    print("  inst.portscan('127.0.0.1 --max-port 80')")
    print("  inst.hasher('hello --algo sha256')")
    print("  inst.hashcrack('auto 3e2573... --wordlist ./passwords.txt')")
    import code
    code.interact(local={**globals(), **{"inst": inst}})


if __name__ == "__main__":
    _interactive_runner()
