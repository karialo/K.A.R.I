# PATCH TARGET: mod_gen.py — K.A.R.I. module scaffolder (classic style + modern hooks)
# -----------------------------------------------------------------------------
# Keeps your original structure/CLI intact:
#   python3 utils/mod_gen.py <Name> <internal|prosthetic> [actions...]
#
# Adds for EVERY generated module:
# • DEBUG toggle (env or core.settings) with safe fallback
# • Mood fallback when MemoryCortex not available (defaults to 'neutral')
# • Safe get_phrase wrapper to avoid hard crashes on missing phrases
# • Pulse-based shared data sync from DEVILCore (same as before)
# • collect_info() including actions list and basic state
# • Phrase tree scaffold (same tags/moods as before)
# • No package __init__.py magic (matches your existing loader)
# -----------------------------------------------------------------------------

import os
import argparse

# ----------------------------- helpers ---------------------------------------
def camel_case(name: str) -> str:
    return ''.join(word.capitalize() for word in name.replace('-', '_').split('_'))

def write_phrases(root_path: str, module_name: str):
    tags  = ["boot", "react", "banter", "wake_up"]
    moods = ["angry", "anxious", "excited", "glitched", "happy", "neutral", "sad"]
    boilerplate = [
        f"{module_name} online.",
        "{cpu_usage}% CPU, stable.",
        "Vitals logged. Ready."
    ]

    os.makedirs(root_path, exist_ok=True)
    for tag in tags:
        tag_path = os.path.join(root_path, tag)
        os.makedirs(tag_path, exist_ok=True)
        for mood in moods:
            file_path = os.path.join(tag_path, f"{mood}.txt")
            if os.path.exists(file_path):
                continue
            with open(file_path, "w") as f:
                for line in boilerplate:
                    f.write(line + "\n")

# ---------------------------- generator --------------------------------------
def generate_module(name: str, category: str, actions):
    class_name = camel_case(name)
    FOLDER_MAP = {"internal": "internal", "prosthetic": "prosthetics"}

    if category not in FOLDER_MAP:
        raise SystemExit("Category must be 'internal' or 'prosthetic'")

    folder = os.path.join(FOLDER_MAP[category], name.lower())
    os.makedirs(folder, exist_ok=True)

    filename    = os.path.join(folder, f"{name.lower()}.py")
    phrases_dir = os.path.join(folder, "phrases")
    write_phrases(phrases_dir, class_name)

    # Render meta as literal text into the module (unchanged semantics)
    meta_block = f'''meta_data = {{
    "name": "{class_name}",
    "version": "1.0",
    "author": "Change me",
    "description": "Description here",
    "category": "{category}",
    "actions": {list(actions)},
    "manual_actions": [
        {{ "name": "Report Module Alive", "function": "report_alive" }},
        {{ "name": "Display Module Info", "function": "display_info" }}
    ],
    "pulse": ["pulse"],
    "capabilities": ["neural_sync"],
    "resources": ["cpu_usage", "mem_usage"]
}}'''

    # Module source (classic style + universal hooks)
    module_code = f'''# Autogenerated module for K.A.R.I.

import os
from core.logger import log_system, log_kari
from core.personality import get_phrase

# Optional internal: MemoryCortex. Fallback mood='neutral' if unavailable.
try:
    from internal.memory_cortex.memory_cortex import MemoryCortex
except Exception:
    MemoryCortex = None  # type: ignore

# Optional global settings: DEBUG flag (env overrides settings if present).
try:
    from core import settings as _kari_settings  # may define DEBUG
    DEBUG = bool(int(os.environ.get("KARI_DEBUG", "0"))) or bool(getattr(_kari_settings, "DEBUG", False))
except Exception:
    DEBUG = bool(int(os.environ.get("KARI_DEBUG", "0")))

{meta_block}

class {class_name}:
    def __init__(self):
        self.meta_data = meta_data
        self.name = self.meta_data["name"]
        self.shared_data = {{}}
        self.core = None  # Assigned at runtime by DEVILCore
        self.ready = False

    # -------------------------- lifecycle --------------------------------
    def init(self):
        self.ready = False
        self.available_phrases = self._load_available_phrases()
        if self.available_phrases:
            log_system("Available phrase triggers loaded:", source=self.name)
            for phrase in sorted(self.available_phrases):
                log_system(f" • {{phrase}}", source=self.name)
        else:
            log_system("No phrase files detected. K.A.R.I. may be speechless.", source=self.name)
        if DEBUG:
            log_system("DEBUG enabled for module.", source=self.name)
        print("")  # aesthetics
        self.ready = True

    # --------------------------- utils -----------------------------------
    def log(self, message):
        log_system(message, source=self.name)

    def _current_mood(self):
        if MemoryCortex:
            try:
                return MemoryCortex().get_current_mood() or "neutral"
            except Exception:
                return "neutral"
        return "neutral"

    def _safe_phrase(self, module_key: str, tag: str, mood: str):
        # Guard against missing files/dirs; return a simple fallback string
        try:
            return get_phrase(module_key, tag, mood)
        except Exception as e:
            if DEBUG:
                self.log(f"get_phrase() failed for tag '{{tag}}' mood '{{mood}}': {{e}}")
            return f"[{{self.name}}] ({{mood}}) {{tag}}"

    def react(self, phrase_file, override_mood=None):
        mood = override_mood or self._current_mood()
        return self._safe_phrase("{name.lower()}", phrase_file, mood)

    def _load_available_phrases(self):
        phrases_path = os.path.join(os.path.dirname(__file__), "phrases")
        if not os.path.exists(phrases_path):
            return []
        subdirs = [f for f in os.listdir(phrases_path) if os.path.isdir(os.path.join(phrases_path, f))]
        return subdirs

    # -------------------------- diagnostics -------------------------------
    def report_alive(self):
        self.log("Status: Online and operational.")

    def display_info(self):
        for key, value in self.meta_data.items():
            self.log(f"{{key}}: {{value}}")

    def healthcheck(self):
        return {{
            "name": self.name,
            "ready": self.ready,
            "has_core": self.core is not None
        }}

    # ----------------------- DEVILCore data sync --------------------------
    def pulse(self):
        if hasattr(self, "core") and hasattr(self.core, "data_store") and self.core.data_store is not None:
            try:
                self.shared_data.update(self.core.data_store)  # shallow sync
                if DEBUG:
                    cpu = self.shared_data.get("cpu_usage")
                    mem = self.shared_data.get("mem_usage")
                    if cpu is not None or mem is not None:
                        self.log(f"Synced shared data (cpu={{cpu}}, mem={{mem}})")
                    else:
                        self.log("Synced shared data.")
            except Exception as e:
                self.log(f"Pulse sync failed: {{e}}")
        else:
            if DEBUG:
                self.log("No DEVILCore data_store to sync.")

    def push_shared_data(self):
        if hasattr(self, "core") and hasattr(self.core, "data_store") and self.core.data_store is not None:
            # Example place to publish back into core if needed
            # self.core.data_store["last_"+self.name] = "...timestamp..."
            pass

    def show_shared_data(self):
        if not self.shared_data:
            self.log("No shared data found.")
        else:
            self.log("Shared data:")
            for k, v in self.shared_data.items():
                self.log(f"  {{k}}: {{v}}")

    def collect_info(self):
        return {{
            "Module Info": {{
                "name": self.meta_data["name"],
                "version": self.meta_data["version"],
                "author": self.meta_data["author"],
                "description": self.meta_data["description"]
            }},
            "State": {{
                "ready": self.ready
            }},
            "Actions": {list(actions)}
        }}
'''

    # Append user-specified actions as no-op methods (classic behavior)
    for action in actions:
        action_name = str(action).strip()
        if not action_name:
            continue
        module_code += f'''

    def {action_name.lower()}(self):
        self.log("Executing action: {action_name}")'''

    with open(filename, "w") as f:
        f.write(module_code)

    print(f"✅ {category.capitalize()} module '{class_name}' generated at '{filename}'.")
    print(f"\U0001F5E8️  Phrase structure scaffolded under '{phrases_dir}'.")

# --------------------------------- CLI ----------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a K.A.R.I. module (internal or prosthetic).")
    parser.add_argument("name", help="Module name (e.g. Heartbeat, NetSynapse)")
    parser.add_argument("type", choices=["internal", "prosthetic"], help="Module category")
    parser.add_argument("actions", nargs="*", help="List of action methods")

    args = parser.parse_args()
    generate_module(args.name, args.type, args.actions)
